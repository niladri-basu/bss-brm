/*
 *
* Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved. 
 *
 *      This material is the confidential property of Oracle Corporation or its
 *      licensors and may be used, reproduced, stored or transmitted only in
 *      accordance with a valid Oracle license or sublicense agreement.
 *
 */

#ifndef lint
static  char Sccs_id[] = "@(#)$Id: fm_gl_pol_pre_update_journal_custom.c /cgbubrm_7.3.2.rwsmod/1 2010/05/06 14:49:36 mnarasim Exp $";
#endif

/*******************************************************************
 * Contains the PCM_OP_GL_POL_PRE_UPDATE_JOURNAL operation.
 *******************************************************************/

#include "pcm.h"
#include "ops/bill.h"
#include "cm_fm.h"

EXPORT_OP void
op_gl_pol_pre_update_journal(
	cm_nap_connection_t	*connp,
	int32			opcode,
	int32			flags,
	pin_flist_t		*in_flistp,
	pin_flist_t		**ret_flistpp,
	pin_errbuf_t		*ebufp);

static void fm_gl_pol_pre_update_journal(
	pcm_context_t		*ctxp,
	int32			flags,
	pin_flist_t		*in_flistp,
	pin_flist_t		**ret_flistpp,
	pin_errbuf_t		*ebufp);

/**
 * Main routine for the PCM_OP_GL_POL_PRE_UPDATE_JOURNAL operation. This
 * policy can be used to customize the general ledger journal entries before
 * they are written in the database. By default, it will return the same
 * journal entries that it receives in its input.
 *
 * This policy can be customized to return a different set of journal entries
 * to be written to the database. The returned set can be generated by adding
 * to, removing from or modifying the input set of journal entries.
 *
 * The input can contain journal entries that are about to be inserted or
 * updated in the database. The POID ID of the /journal object in each journal
 * entry in the input will be -1 or a valid ID depending on whether a new
 * journal object is to be inserted or an existing one updated. Any modified
 * or new journal entry in the return flist should also contain /journal POID
 * ID as appropriate.
 *
 * A journal object is determined to exist in the database based on its
 * identity defined by the combination of fields PIN_FLD_ITEM_OBJ,
 * PIN_FLD_GL_ID, PIN_FLD_RESOURCE_ID, PIN_FLD_EARNED_START_T and
 * PIN_FLD_EARNED_END_T.
 *
 * @param connp The connection pointer.
 * @param opcode This opcode.
 * @param flags The opcode flags.
 * @param in_flistp The input flist that contains the PIN_FLD_EVENT substruct
 *        with all data for the currently processed event and
 *        PIN_FLD_JOURNAL_INFO array with the journal entries underneath.
 * @param ret_flistpp The output flist with a possibly modified set of journal
 *        entries.
 * @param ebufp The error buffer.
 * @return nothing.
 */
void
op_gl_pol_pre_update_journal(
	cm_nap_connection_t	*connp,
	int32			opcode,
	int32			flags,
	pin_flist_t		*in_flistp,
	pin_flist_t		**ret_flistpp,
	pin_errbuf_t		*ebufp)
{
	pcm_context_t		*ctxp = connp->dm_ctx;

	*ret_flistpp = NULL;

	if (PIN_ERR_IS_ERR(ebufp)) {
		return;
	}
	PIN_ERR_CLEAR_ERR(ebufp);

	/*******************************************************************
	 * Insanity check.
	 *******************************************************************/
	if (opcode != PCM_OP_GL_POL_PRE_UPDATE_JOURNAL) {
		pin_set_err(ebufp, PIN_ERRLOC_FM,
			PIN_ERRCLASS_SYSTEM_DETERMINATE,
			PIN_ERR_BAD_OPCODE, 0, 0, opcode);
		PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR,
			"op_gl_pol_pre_update_journal bad opcode error",
			ebufp);
		return;
	}

	/*******************************************************************
	 * Debug: What we got.
	 *******************************************************************/
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG,
		"op_gl_pol_pre_update_journal input flist", in_flistp);

	/*******************************************************************
	 * Do the actual operation
	 *******************************************************************/
	fm_gl_pol_pre_update_journal(ctxp, flags, in_flistp,
				ret_flistpp, ebufp);

	if (PIN_ERR_IS_ERR(ebufp)) {
		PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR,
		"op_gl_pol_pre_update_journal error", ebufp);
	} else {
		PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG,
		"op_gl_pol_pre_update_journal output flist", *ret_flistpp);
	}
	return;
}

/**
 * This function is the actual implementation of the policy.
 * @param connp The context pointer.
 * @param flags The opcode flags.
 * @param in_flistp The input flist.
 * @param ret_flistpp The output flist. Contains POID and JOURNAL_INFO.
 * @param ebufp The error buffer.
 * @return nothing.
 */
static void
fm_gl_pol_pre_update_journal(
	pcm_context_t		*ctxp,
	int32			flags,
	pin_flist_t		*in_flistp,
	pin_flist_t		**ret_flistpp,
	pin_errbuf_t		*ebufp)
{
	void			*vp = NULL;
	pin_cookie_t 		cookie = NULL;
	int32			rec_id = 0;
	pin_flist_t		*j_flistp = NULL;

	if (PIN_ERR_IS_ERR(ebufp)) {
		return;
	}
	PIN_ERR_CLEAR_ERR(ebufp);

	/*******************************************************************
	 * Default implementation is just to return a copy of the input
	 * journal entries.
	 *******************************************************************/

	*ret_flistpp = PIN_FLIST_CREATE(ebufp);
	vp = PIN_FLIST_FLD_GET(in_flistp, PIN_FLD_POID, 0, ebufp);
	PIN_FLIST_FLD_SET(*ret_flistpp, PIN_FLD_POID, vp, ebufp);

	while ((j_flistp = PIN_FLIST_ELEM_GET_NEXT(in_flistp,
		PIN_FLD_JOURNAL_INFO, &rec_id, 1, &cookie, ebufp)) != NULL) {

		PIN_FLIST_ELEM_SET(*ret_flistpp, j_flistp,
			PIN_FLD_JOURNAL_INFO, rec_id, ebufp);
	}

	if (PIN_ERR_IS_ERR(ebufp)) {
		PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR,
		"fm_gl_pol_pre_update_journal error", ebufp);
	}

	return;
}
