#!/brmapp/portal/ThirdParty/perl/5.18.2/bin/perl
#
#	@(#)%Portal Version: partition_utils.pl:PlatformR2Int:11:2006-Sep-12 03:38:18 %
#       
# Copyright (c) 1996, 2010, Oracle and/or its affiliates. All rights reserved. 
#       
#       This material is the confidential property of Oracle Corporation or its
#       licensors and may be used, reproduced, stored or transmitted only in
#       accordance with a valid Oracle license or sublicense agreement.
#

# A wrapper for all partition-related operation Infranet users are exposed to.
use Time::localtime;
use Time::Local;
use lib "$ENV{PIN_HOME}/apps/partition_utils";
use aes;

$in_progress_msg     = "This process may take several minutes to complete. Please do not abort this process!\nIn progress...\n";
$command_success_msg = "\nCommand completed successfully .\n";
$look_into_log_msg   = "\nLook into partition_utils.log for detail error messages\n";
#
# Error Codes Generated by this script
#
$ERR_LIMIT_REAL_START_DATE			= 10001;   
$ERR_LIMIT_DELAYED_START_DATE			= 10002;   
$ERR_LIMIT_REAL_DAILY_QUANTITY			= 10003;   
$ERR_LIMIT_REAL_WEEKLY_QUANTITY			= 10004;   
$ERR_LIMIT_REAL_MONTHLY_QUANTITY		= 10005;   
$ERR_LIMIT_DELAYED_DAILY_QUANTITY		= 10006;   
$ERR_LIMIT_DELAYED_WEEKLY_QUANTITY		= 10007;   
$ERR_LIMIT_DELAYED_MONTHLY_QUANTITY		= 10008;   
$ERR_LIMIT_REAL_DAILY_WIDTH			= 10009;   
$ERR_LIMIT_REAL_WEEKLY_WIDTH			= 10010;   
$ERR_LIMIT_REAL_MONTHLY_WIDTH			= 10011;   
$ERR_LIMIT_DELAYED_DAILY_WIDTH			= 10012;   
$ERR_LIMIT_DELAYED_WEEKLY_WIDTH			= 10013;   
$ERR_LIMIT_DELAYED_MONTHLY_WIDTH		= 10014;   
$ERR_LIMIT_REAL_OLDER_THAN			= 10015;   
$ERR_LIMIT_DELAYED_OLDER_THAN			= 10016;
$ERR_RANGE_START_DATE			        = 10017;
$ERR_RANGE_QUANTITY		                = 10018;
$ERR_RANGE_WIDTH		        	= 10019;
$ERR_RANGE_END_DATE_OLDER_THAN			= 10020;
$ERR_INVALID_SYNTAX				= 10021;
$ERR_START_DATE_MORE_THAN_END_DATE		= 10022;
$ERR_WIDTH_NEGATIVE_ZERO			= 10023;
$ERR_ONLY_ENABLE_DELAYED_SUPPORTED		= 10024;
$ERR_START_DATE_FORMAT				= 10025;
$ERR_END_DATE_FORMAT				= 10026;
$ERR_INVALID_PARTITION_TYPE			= 10027;
$ERR_INVALID_UNIT				= 10028;
$ERR_QUANTITY_NEGATIVE_ZERO			= 10029;
$ERR_INVALID_CLASS_NAME				= 10030;
$ERR_LIMIT_PURGE_THRESHOLD			= 10031;
$ERR_LIMIT_NUM_OF_PROCESSES			= 10032;
$ERR_LIMIT_MAX_DEL_REC				= 10033;
$ERR_LIMIT_MAX_DEL_REC_CHUNK			= 10034;
$ERR_INVALID_BASE_CLASS_NAME			= 10035;
$ERR_DELAYED_NOT_SUPPORTED			= 10036;
$ERR_SINGLE_CLASS_NAME				= 10037;

####################################################
#These are the error codes expected from Oracle PL/SQL
#
# 
# $ERR_BASE_NOT_PARTITIONED               = -20001;
# $ERR_SPILL_OVER_REAL                    = -20002;
# $ERR_REAL_START_DATE_ACTIVE             = -20003;
# $ERR_ONE_INSTANCE_ALLOWED               = -20004;
# $ERR_FUTURE_PARTITION_NOT_EMPTY         = -20005;
# $ERR_PAST_START_DATE                    = -20006;
# $ERR_DROP_ACTIVE_PARTITION              = -20007;
# $ERR_UPDATE_REAL_ACTIVE_SPLIT           = -20008;
# $ERR_NO_TABLES_FOR_THIS_CLASS           = -20009;
# $ERR_DELAYED_START_DATE_ACTIVE          = -20010;
# $ERR_UPDATE_DELAY_ACTIVE_SPLIT          = -20011;
# $ERR_SPILL_OVER_DELAYED                 = -20012;
# $ERR_NO_DBA_PRIVILEGE                   = -20014;
# $ERR_LAST_COMMAND_FAILED                = -20015;
###################################################

$ERR_REAL_START_DATE_ACTIVE             = -20003;
$ERR_ONE_INSTANCE_ALLOWED               = -20004;
$ERR_DELAYED_START_DATE_ACTIVE          = -20010;
$ERR_NO_PURGE_EVENT                     = -20013;
$ERR_PURGE_ELIGIBILITY                  = -20016;
$ERR_UNKNOWN_PIN_PARTITION_CODE         = -20099;

# $me is the name of executable used to print usage.
($me = $0) =~ s,.*/,,;

$usage_all =
"Usage: $me
	-o <add, remove, enable, update, purge, maxpoid, restart>
	-t <realtime, delayed>
	-s <start-date (MMDDYYYY)>
	-e <end-date (MMDDYYYY)>
	-q <quantity>
	-u <month, week, day>
	-c <storable-class>
	[-w] <width>
	[-f]  <Forces the creation of partitions even if the start date is included in the current partition, for add operation>
	     <Forces the removal of partitions that contain objects that are associated with an open item, for remove operation>
	[-p] <Writes an SQL statement of the operation to the partition_utils.log file but does not perform any action on the database.>
	[-b] <Bypasses executing the last operation but cleans the status of it, for restart operation>
	    <Creates backdated partitions, for add operation>
	-h   <Displays the syntax and parameters for this utility>

Use $me -o option -h to get help for each option.
Like $me -o add -h to get syntax of add option.
";

$usage_add =
"Usage: $me
Operation: add - Applies the new partition allocations across all of the
	partitioned tables of the type specified by the -t option.  The -f option can be 
	used to force the adding of partitions even if the start date is in the 
	currently active partition. Delayed partitioning type is not supported for
	non-event classes.
	The option -b is used to create backdated partitions.

partition_utils
	-o add
	-t <realtime, delayed>	
	-s <start-date (MMDDYYYY)>
	-u <month, week, day>
	-q <quantity>	
	[-c <storable-baseclass>] default=/event
	[-w <width>]				
	[-f <Forces the creation of partitions even if the start date is included in the current partition.> ]
        [-p <Writes an SQL statement of the operation to the partition_utils.log file but does not perform any action on the database.>]
        [-b <Creates backdated partitions>]
";

$usage_remove =
"Usage: $me
Operation: remove - Drops the subset of realtime and/or delayed 
	partitions which completely lie between the start-date and 
	end-date. The Force flag can be used to ignore non-closed items
	and drop the partitions anyway.  The -t option can be used to drop 
	only the realtime or only the delayed set of partitions, 
	not both - which is the default. Delayed partitioning type is not supported
	for non-event classes.

partition_utils
	-o remove
	-s <start-date (MMDDYYYY)>
	-e <end-date (MMDDYYYY)>
	[-t <realtime, delayed>]		
	[-c <storable-baseclass>] default=/event
	[-f <Forces the removal of partitions that contain objects that are associated with an open item. By default, these partitions aren.t removed.>]
        [-p <Writes an SQL statement of the operation to the partition_utils.log file but does not perform any action on the database.>]
";

$usage_enable =
"Usage: $me
Operation: enable - Enables delayed partitions for the given 
	storable-class and all its parent storable-classes.
	This option works only for event classes.

partition_utils
	-o enable
	-t delayed
	-c <storable-class>
	[-p <Writes an SQL statement of the operation to the partition_utils.log file but does not perform any action on the database.>]                                   
";

$usage_update =
"Usage: $me
Operation: update - Ensures the future partitions are in sync across
	all of the partitioned tables of given class in Infranet.
	(This should be used after adding a new subclass, or 
	adding an array or substruct to an existing class in order to 
	partition the new tables appropriately.

partition_utils
	-o update
	[-c <storable-baseclass>] default=/event
	[-p <Writes an SQL statement of the operation to the partition_utils.log file but does not perform any action on the database.>]
";

$usage_purge =
"Usage: $me
Operation: purge - Deletes the processed events and non balance impact events 
	from partition(s) where the complete partition falls into the given end-date.
	The -p option reports the summary of the partitions to be purged.
	The -t enables the option to use either realtime or delayed partitions,
	unlike both will be processed. Delayed partitioning type is not supported for
	non-event classes.

partition_utils
	-o purge
	-e <end-date (MMDDYYYY)>
	[-c <storable-baseclass>] default=/event
	[-t <realtime, delayed>]
	[-p <Writes a report of purgeable objects to the partition_utils.log file but does not perform any action on the database.>]
";
$usage_maxpoid =
"Usage: $me
Operation: maxpoid - Returns the maxpoid of the given date
	for the partition_type specified.

partition_utils
	-o maxpoid
	-s <date (MMDDYYYY)>
	-t <realtime, delayed>
";
$usage_restart =
"Usage: $me
Operation: restart - Reexecute the last operation which was unsuccessful
	due to an error or abnormal termination. 
	The -b option bypass the last operation and cleans the
	status of it.

partition_utils
	-o restart
	[-b <Bypasses executing the last operation but cleans the status of it.>]
";
#$usage ="$usage_all\n$usage_add\n$usage_remove\n$usage_enable\n$usage_update\n$usage_purge\n".
#	"$usage_maxpoid\n$usage_restart\n";

#
# Check -c option - only one class name is allowed.
#
&validate_class_name();
#
# Required for parsing command line options.
#
require "getopts.pl";

#
# Get the input options
#
&Getopts('ho:c:s:e:t:q:w:u:pbf') || handle_invalid_syntax();

#
# Exit if help is expected.
#
if (defined $opt_h) {
	if (defined $opt_o) {
		if (lc($opt_o) eq "add") {
			print $usage_add;
		} elsif (lc($opt_o) eq "remove") {
			print $usage_remove;
		} elsif (lc($opt_o) eq "enable") {
			print $usage_enable;
		} elsif (lc($opt_o) eq "update") {
			print $usage_update;
		} elsif (lc($opt_o) eq "purge") {
			print $usage_purge;
		} elsif (lc($opt_o) eq "maxpoid") {
			print $usage_maxpoid;
		} elsif (lc($opt_o) eq "restart") {
			print $usage_restart;
		}
	}
	else {
	print $usage_all;
	}
	exit(0);
}
require "partition_utils.values";
$validate_err_code = validate_partition_utils_values();
if ($validate_err_code != 0) {	
	handle_errors($validate_err_code, 0);
}

# 
# Global variables 
#
	my $base_class			= "/event";
	my $partition_type_flag		= 1; # 1-both 2-realtime 3-delayed
	my $os;
	my $osuser;
	my $system;
	my $dbuser;
	my $index_type;
	my $nop				= $NUM_OF_PROCESSES;
	my $exec_flag			= "TRUE";   # by default exec flag is TRUE.

	sleep(1);
	my $timeinsec			= time; # current time in number of seconds from 1 Jan 1970


# Get system, os user and database user name

	$os = $ENV{"OS"};
	$dbuser = $MAIN_DB{'user'}; 
	if( index(lc($os), "win") >= 0) {
		$osuser = $ENV{USERNAME};
		$system = $ENV{COMPUTERNAME};
	}
	else  {
		$os	= `uname`;
		$osuser = $ENV{USER};
		$system = `uname -n`;
	}
	chomp($os);
	chomp($dbuser);
	chomp($osuser);
	chomp($system);

#
# Do the job accordingly
#
DOBLOCK: {                
  if ($opt_o) {			
	if (lc($opt_o) eq "add") {
		my $width		= 1;  # 1 is the default value of width.
		my $unit;
		my $force_flag		= "FALSE"; # By default force flag is FALSE.
		my $delayed_flag;
		my $backdated_flag	= "FALSE";
		my $cmd;
		my $set_boundary_flag	= "TRUE";
		# 
		# check for Arguments
		#
		$ret = &get_no_of_arguments (lc($opt_o));
		if ($ret < 4) {
			print "$usage_add\n";
			handle_errors($ERR_INVALID_SYNTAX, 0);
		} 
		#
		# validation of base class
		#				
		validate_base_class();

		#
		# evaluate partition type
		#
		evaluate_partition_type();
		$ret = &is_date_valid ($opt_s);
		if ($ret != 0) {
			handle_errors($ERR_START_DATE_FORMAT, 0);				
		}
		if (lc($opt_t) eq "realtime") {			
			$delayed_flag = "FALSE";
			if (!defined $opt_b) {
				$ret = &is_date_in_range ($opt_s,-1,$MAX_ADD_REAL{'start_date'});
				if ($ret != 0) {
					print "Limit = $MAX_ADD_REAL{'start_date'} days \n";
					handle_errors($ERR_RANGE_START_DATE, 0);
				}
			}
		} else {
			$delayed_flag = "TRUE";
			if (!defined $opt_b) {
				$ret = &is_date_in_range ($opt_s,-1,$MAX_ADD_DELAYED{'start_date'});
				if ($ret != 0) {
					print "Limit = $MAX_ADD_DELAYED{'start_date'} days \n";
					handle_errors($ERR_RANGE_START_DATE, 0);
				}
			}
		}
		# 
		# check for unit value
		#
		if (lc($opt_u) eq "day") {
			$unit = 2;
		} elsif (lc($opt_u) eq "week") {
			$unit = 1;
		} elsif (lc($opt_u) eq "month") {
			$unit = 0;
		}else {
			handle_errors($ERR_INVALID_UNIT, 0);
		}			    
		# 
		# check for quantity
		#
		if ($opt_q <= 0) {
			handle_errors($ERR_QUANTITY_NEGATIVE_ZERO, 0);	
		}
		#
		# check for quantity Values
		#
		if (lc($opt_t) eq "realtime") {	
			if ($unit == 0) {
				if ($opt_q > $MAX_ADD_REAL{'monthly_quantity'}) {
					print "Limit = $MAX_ADD_REAL{'monthly_quantity'} \n";
					handle_errors($ERR_RANGE_QUANTITY, 0);
				}
			}elsif ($unit == 1) {
				if ($opt_q > $MAX_ADD_REAL{'weekly_quantity'}) {
					print "Limit = $MAX_ADD_REAL{'weekly_quantity'} \n";
					handle_errors($ERR_RANGE_QUANTITY, 0);
				}
			}else {
				if ($opt_q > $MAX_ADD_REAL{'daily_quantity'}) {
					print "Limit = $MAX_ADD_REAL{'daily_quantity'} \n";
					handle_errors($ERR_RANGE_QUANTITY, 0);
				}
			}
		} elsif ((lc($opt_t) eq "delayed")) {
			if ($unit == 0) {
				if ($opt_q > $MAX_ADD_DELAYED{'monthly_quantity'}) {
					print "Limit = $MAX_ADD_DELAYED{'monthly_quantity'} \n";
					handle_errors($ERR_RANGE_QUANTITY, 0);
				}
			} elsif ($unit == 1) {
				if ($opt_q > $MAX_ADD_DELAYED{'weekly_quantity'}) {
					print "Limit = $MAX_ADD_DELAYED{'weekly_quantity'} \n";
					handle_errors($ERR_RANGE_QUANTITY, 0);
				}
			} else {
				if ($opt_q > $MAX_ADD_DELAYED{'daily_quantity'}) {
					print "Limit = $MAX_ADD_DELAYED{'daily_quantity'} \n";
					handle_errors($ERR_RANGE_QUANTITY, 0);
				}
			}
		}
		#
		# validation of Width
		#
		if (defined $opt_w) {
			$width = $opt_w;
			if ($width <= 0) {
				handle_errors($ERR_WIDTH_NEGATIVE_ZERO, 0);	
			}
		}
		if (lc($opt_t) eq "realtime") {	
			if ($unit == 0) {
				if ($width > $MAX_ADD_REAL{'monthly_width'}) {
					print "Limit = $MAX_ADD_REAL{'monthly_width'} \n";
					handle_errors($ERR_RANGE_WIDTH, 0);
				}
			}elsif ($unit == 1) {
				if ($width > $MAX_ADD_REAL{'weekly_width'}) {
					print "Limit = $MAX_ADD_REAL{'weekly_width'} \n";
					handle_errors($ERR_RANGE_WIDTH, 0);
				}
			}else {
				if ($width > $MAX_ADD_REAL{'daily_width'}) {
					print "Limit = $MAX_ADD_REAL{'daily_width'} \n";
					handle_errors($ERR_RANGE_WIDTH, 0);
				}
			}
		} elsif (lc($opt_t) eq "delayed") {
			if ($unit == 0) {
				if ($width > $MAX_ADD_DELAYED{'monthly_width'}) {
					print "Limit = $MAX_ADD_DELAYED{'monthly_width'} \n";
					handle_errors($ERR_RANGE_WIDTH, 0);
				}
			} elsif ($unit == 1) {
				if ($width > $MAX_ADD_DELAYED{'weekly_width'}) {
					print "Limit = $MAX_ADD_DELAYED{'weekly_width'} \n";
					handle_errors($ERR_RANGE_WIDTH, 0);
				}
			} else {
				if ($width > $MAX_ADD_DELAYED{'daily_width'}) {
					print "Limit = $MAX_ADD_DELAYED{'daily_width'} \n";
					handle_errors($ERR_RANGE_WIDTH, 0);
				}
			}
		}
		#
		# validation of force flag
		#
		if (defined $opt_f) {
			$force_flag = "TRUE";
		} 				
		#
		# validation of backdated flag
		#
		if (defined $opt_b) {
			$backdated_flag = "TRUE";
		}
		#
		# validation of printonly flag
		#
		if (defined $opt_p) {
			$exec_flag = "FALSE";
		} 

		#
		# Call stored procedures
		#
		print $in_progress_msg;
		$tm = localtime;
		print "Begin Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",
			$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
		print "Executing add_partitions_init............\n";
		&exe_sql("EXEC PIN_PARTITION.add_partitions_init('$system','$osuser', '$dbuser',".
		"'$base_class','$opt_s',$delayed_flag,$unit,$width,$opt_q,$nop,$exec_flag,".
		"$force_flag,$backdated_flag,$timeinsec)", 0);
		handle_errors(0, 0);
		read_index_type();
		if (string_exists("session.log", "ALREADY_SET_BOUNDARY") == 1) {
			$set_boundary_flag = "FALSE";
		}
		$cmd = "EXEC PIN_PARTITION.add_partitions_exec($delayed_flag, $set_boundary_flag, $exec_flag)";
		print "Executing add_partitions_exec procedure............\n";
		$tm = localtime;
		print "Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",
			$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
		exec_in_parallel($cmd, 0);
		$tm = localtime;
		print "Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",
			$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
		rebuild_indexes(1);
		print "End Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",
			$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
		print $command_success_msg;
		exit(0);
	} # end of validation of add option.
	elsif (lc($opt_o) eq "remove") {
		my $GuardFlag	= "TRUE"; # by default we will guard open item partitions.

		# 
		# check for Arguments
		#
		$ret = &get_no_of_arguments (lc($opt_o));
		if ($ret < 2) {
			print "$usage_remove\n";
			handle_errors($ERR_INVALID_SYNTAX, 0);
		}	

		#
		# validation of base class
		#
		validate_base_class();

		#
		# evaluate partition type
		#
		evaluate_partition_type();

		# 
		# check  Date
		#
		$ret = &is_date_valid ($opt_s);
		if ($ret != 0) {
			handle_errors($ERR_START_DATE_FORMAT, 0);
		}
		$ret = &is_date_valid ($opt_e);
		if ($ret != 0) {
			handle_errors($ERR_END_DATE_FORMAT, 0);
		}	

		#
		# for realtime
		#
		if ($partition_type_flag == 1 or $partition_type_flag == 2) {
			if ($ENV{TESTING} != 1) {
				$ret = &is_date_in_range ($opt_e,0,-1*$MAX_REMOVE_REAL{'older_than'});
				if ($ret != 0) {
					print "Limit = $MAX_REMOVE_REAL{'older_than'} days\n";
					handle_errors($ERR_RANGE_END_DATE_OLDER_THAN, 0);
				}
			}
			$ret = end_more_than_start($opt_s, $opt_e);
			if ($ret != 0) {
				handle_errors($ERR_START_DATE_MORE_THAN_END_DATE, 0);
			}	
		}
		#
		# for delayed
		#
		if ($partition_type_flag == 1 or $partition_type_flag == 3) {
			if ($ENV{TESTING} != 1) {
				$ret = &is_date_in_range ($opt_e,0,-1*$MAX_REMOVE_DELAYED{'older_than'});
				if ($ret != 0) {
					print "Limit = $MAX_REMOVE_DELAYED{'older_than'} days\n";
					handle_errors($ERR_RANGE_END_DATE_OLDER_THAN, 0);
				}
			}
			$ret = end_more_than_start($opt_s, $opt_e);
			if ($ret != 0) {
				handle_errors($ERR_START_DATE_MORE_THAN_END_DATE, 0);
			}	
		}

		#
		#Validation of Force Flag
		#
		if (defined ($opt_f) ) {
			# Get the confirmation from the user twice
			print "\nForce flag will drop the partitions that lies in the given range without ",
				"any conditional checking.\nAre you sure to drop the partitions?(y/n)";
			$inputkey = <STDIN>;
			chomp($inputkey);
			if (lc($inputkey) ne "y"){
				exit(0);
			}
			print "\nForce flag will drop the partitions that lies in the given range without ",
				"any conditional checking.\nAre you sure to drop the partitions?(y/n)";
			$inputkey = <STDIN>;
			chomp($inputkey);
			if (lc($inputkey) ne "y"){
				exit(0);
			}
			$GuardFlag = "FALSE";
		}

		#
		# validation of printonly
		#
		if (defined $opt_p) {
			$exec_flag = "FALSE";
		}

		#
		# Call stored procedures
		#
		print $in_progress_msg;
		#
		# for realtime
		#
		if ($partition_type_flag == 1 or $partition_type_flag == 2) {
			drop_partition_process("FALSE", $GuardFlag);
			clean_up(0);
		} 
		#
		# for delayed
		#
		if ( $base_class eq "/event" ) {
			if ($partition_type_flag == 1 or $partition_type_flag == 3) {
				drop_partition_process("TRUE", $GuardFlag);
			}
		}
		rebuild_indexes(1);
		print "End Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",
			$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
		print $command_success_msg;
		exit(0);
	} elsif (lc($opt_o) eq "enable") {                
		# 
		# check for Arguments
		#
		$ret = &get_no_of_arguments (lc($opt_o));
		if ($ret != 2) {
			print "$usage_enable\n";
			handle_errors($ERR_INVALID_SYNTAX, 0);
		}

		#
		# validation of class argument
		#
		if (defined $opt_c) {
			if ($opt_c =~ /^\/event\//) {
			}
			else {
				handle_errors($ERR_INVALID_CLASS_NAME, 0);
			}
		}

		#
		# validation of partition type
		#
		if (lc($opt_t) ne "delayed") {
			handle_errors($ERR_ONLY_ENABLE_DELAYED_SUPPORTED, 0);
		}

		#
		# validation of printonly flag
		#
		if (defined $opt_p) {
			$exec_flag = "FALSE";
		} 
		print $in_progress_msg;
		&exe_sql("EXEC PIN_PARTITION.enable_delayed_partitioning".
			"('$system','$osuser', '$dbuser','$opt_c', $exec_flag, $timeinsec)", 0);
		handle_errors(0, 0);
		update_process("TRUE", "TRUE");
		clean_up(0);
		print $command_success_msg;
		exit(0);
	} elsif (lc($opt_o) eq "update") { 
		my $force_flag	= "FALSE"; # by default force flag is FALSE.
		$ret = &get_no_of_arguments (lc($opt_o));
		if ($ret != 0) {
			print "$usage_update\n";
			handle_errors($ERR_INVALID_SYNTAX, 0);       		
		}
		#
		# validation of base class
		#
		validate_base_class();
		#
		# validation of printonly flag
		#
		if (defined $opt_p) {
			$exec_flag = "FALSE";
		} 
		#
		# validation of force flag
		#
		if (defined $opt_f) {
			$force_flag = "TRUE";
		}
		#
		# Call stored procedures
		#
		print $in_progress_msg;
		$tm = localtime;
		print "Begin Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",
			$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
		update_process("FALSE", $force_flag);
		clean_up(0);
		if ( $base_class eq "/event" ) {
			update_process("TRUE", $force_flag);
		}
		$tm = localtime;
		print "Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",
			$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
		rebuild_indexes(1);
		print "End Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",
			$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
		print $command_success_msg;
		exit(0);				
	} elsif (lc($opt_o) eq "purge") {
		#
		# check for Arguments
		#
		$ret = &get_no_of_arguments (lc($opt_o));
		if ($ret < 1) {
			print "$usage_purge\n";
			handle_errors($ERR_INVALID_SYNTAX, 0);
		}
		#
		# validation of base class
		#				
		validate_base_class();

		#
		# evaluate partition type
		#
		evaluate_partition_type();

		#
		# check Date
		#
		$ret = &is_date_valid ($opt_e);
		if ($ret != 0) {
			handle_errors($ERR_END_DATE_FORMAT, 0);
		}
		#	
		# validation of given end date
		#
		#
		# for realtime
		#
		if ($partition_type_flag == 1 or $partition_type_flag == 2) {
			if ($ENV{TESTING} != 1) {
				$ret = &is_date_in_range ($opt_e, 0, -1*$MAX_REMOVE_REAL{'older_than'} );
				if ($ret != 0) {
					print "Limit = $MAX_REMOVE_REAL{'older_than'} days\n";
					handle_errors($ERR_RANGE_END_DATE_OLDER_THAN, 0);
				}
			}
		}
		#
		# for delayed
		#
		if ($partition_type_flag == 1 or $partition_type_flag == 3) {
			if ($ENV{TESTING} != 1) {
				$ret = &is_date_in_range ($opt_e, 0, -1*$MAX_REMOVE_DELAYED{'older_than'} );
				if ($ret != 0) {
					print "Limit = $MAX_REMOVE_DELAYED{'older_than'} days\n";
					handle_errors($ERR_RANGE_END_DATE_OLDER_THAN, 0);
				}
			}
		}
		#
		# validation of printonly
		#
		if (defined $opt_p) {
			$exec_flag = "FALSE";
		}

		#
		# Call stored procedures
		#
		print $in_progress_msg;
		#
		# for realtime
		#
		if ($partition_type_flag == 1 or $partition_type_flag == 2) {
			purge_partition_process(FALSE);
			clean_up(0);
		} 
		#
		# for delayed
		#
		if ( $base_class eq "/event" ) {
			if ($partition_type_flag == 1 or $partition_type_flag == 3) {
				purge_partition_process(TRUE);
			}
		}
		rebuild_indexes(1);
		print "End Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",
			$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
		print $command_success_msg;
		exit(0);
	} elsif (lc($opt_o) eq "maxpoid") {
		my $delayed_flag	= 0;
		#
		#   Check for arguments
		#
		$ret = &get_no_of_arguments (lc($opt_o));
		if ($ret < 2) {
			print "$usage_maxpoid\n";
			handle_errors($ERR_INVALID_SYNTAX, 0);
		}
		$ret = &is_date_valid ($opt_s);
		if ($ret != 0) {
			handle_errors($ERR_START_DATE_FORMAT, 0);
		}
		#
		# check partition_type
		#
		if ((lc($opt_t) ne "realtime") and (lc($opt_t) ne "delayed")) {
			handle_errors($ERR_INVALID_PARTITION_TYPE, 0);
		}
		if (lc($opt_t) eq "delayed") {
			$delayed_flag = 1;
		}
		&exe_sql("select PIN_PARTITION.maxpoid('$opt_s',$delayed_flag) POID from dual", 0);
		handle_errors(0, 0);
		exit(0);
	} elsif (lc($opt_o) eq "restart") {
		my $bypass = 0;
		my $found = 0;
		#
		# validation of bypass option
		#
		if (defined($opt_b)) {
			$bypass = 1;
		}
		$tm = localtime;
		print "Begin Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",
					$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
		print "Executing restart_init............\n";
		&exe_sql("EXEC PIN_PARTITION.restart_init($bypass)", 0);
		read_index_type();
		handle_errors(0, 0);
		$found = string_exists("session.log", "SKIP_RESTART_EXEC");	
		if ( $found == 0 ) {
			$found = string_exists("session.log", "PURGE");	
			if ($found == 0) {
				$cmd = "EXEC PIN_PARTITION.restart_exec";
				print "Executing restart_exec procedure............\n";
				$tm = localtime;
				print "Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",
					$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
				exec_in_parallel($cmd, 0);
			} else {
				my (@par_array) = read_partition_names();
				do_purge(@par_array);
				$tm = localtime;
				print "Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",
					$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
			}
			rebuild_indexes(1);
		}
		$tm = localtime;
		print "End Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",
			$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
		print $command_success_msg;
		exit(0);
	} elsif (lc($opt_o) eq "test") {
		if ($ENV{TESTING} == 1) {
			&exe_sql("EXEC PIN_PARTITION.test_pin_partition(2)", 0);
			handle_errors(0, 0);
		}
		else
		{
			print "This option works only in TEST environment\n";
			print "If so then set environment variable TESTING to 1\n";
		}
	} else { 
		handle_invalid_syntax();
	}
  }
  else { 
	handle_invalid_syntax();
  }
last DOBLOCK;
}

#
# populates purgable and non-purgable poids in temporary tables.
# Partition which has 70%(based on $PURGE_THRESHOLD) purgable events are only eligible for purging and
# purging will be done in parallel by calling purge_partitions_exec and also prints summary report.
#
sub do_purge{
	local (@parr)	= @_;
	local $parname;
	local $i;
	local $cmd;
	foreach $parname (@parr)
	{
		&exe_sql("EXEC PIN_PARTITION.purge_get_poids('$parname', $PURGE_THRESHOLD)", 0);
		if( handle_errors(0, 0) != $ERR_NO_PURGE_EVENT )
		{
			$cmd = "EXEC PIN_PARTITION.purge_partitions_exec('$parname', $exec_flag, ".
				"$MAX_DEL_REC, $MAX_DEL_REC_CHUNK,";
			print "Executing purge_partitions_exec procedure............\n";
			$tm = localtime;
			print "Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",
				$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
			exec_in_parallel($cmd, 1);
		}
	}
	&exe_sql("EXEC PIN_PARTITION.purge_report", 0);
}

#
# execute sql command supplied in the arg
# assume that the package PinPartition is stored in DB already
# different session log files will be opened for different child processes
#
sub exe_sql {
	local ($cmd)		= @_;
	local ($sess_no)	= $_[1];
	local ($status)		= 0;
	local ($exitcode)	= 0;
	local ($sqlshell)	= "";
	local ($tmpfile)	= "pintmp.sql";
	local ($logfile)	= "partition_utils.log";
	local ($tmpoutfile)	= "session.log";
	local ($logfilehdl)	= "LOGFILE";
	local ($tmpfilehdl)	= "TMPFILE";
	local ($tmpoutfilehdl)	= "TMPOUTFILE";
	if ($sess_no != 0)
	{
		$tmpfile = "pintmp".$sess_no.".sql";
		$tmpoutfile = "session".$sess_no.".log";
		$tmpfilehdl = $tmpfilehdl.$sess_no;
		$tmpoutfilehdl = $tmpoutfilehdl.$sess_no;
	}

	#=======================================================
	# Open file for Logging
	#========================================================
	unlink "$tmpoutfile";
	open($logfilehdl, ">>$logfile") ||
	die "$me: cannot open $logfile\n";
	open($tmpoutfilehdl, ">$tmpoutfile") ||
	die "$me: cannot create $tmpoutfile\n";
	#=======================================================
	# Create a temporary file with the sql input.
	#========================================================
	open($tmpfilehdl, ">$tmpfile") ||
	die "$me: cannot create $tmpfile\n";      
	print $tmpfilehdl "set serveroutput on size 1000000\nset linesize 200\n";
	print $tmpfilehdl "column POID format 99999999999999999999999999999999999999\n";
	print $tmpfilehdl "$cmd";
	print $tmpfilehdl "\nexit;\n";
	close($tmpfilehdl);

	if ($MAIN_DB{password} =~ m/^\&aes\|/) {
		$ENV{DB_PASSWORD} = aes::psiu_perl_decrypt_pw($MAIN_DB{'password'});
	} else {
		$ENV{DB_PASSWORD} = $MAIN_DB{'password'};
	}
	
	$sqlshell = "sqlplus $MAIN_DB{'user'}/$ENV{DB_PASSWORD}".
			"@"."$MAIN_DB{'alias'}";

	delete($ENV{DB_PASSWORD});

	#===========================================================
	# SQLPLUS gives a zero status back if the
	# user/passwd is wrong. So, instead of using system(),
	# we need to capture the output
	# of SQLPLUS and parse it to see if there was an error.
	#===========================================================
	$sqlout = `$sqlshell < $tmpfile`;
	$exitcode = $?;
	$status = ($? >> 8);
	unlink "$tmpfile";

	#
	# Log the output
	#
	print $tmpoutfilehdl "$sqlout";
	print $logfilehdl "$sqlout";
	close($logfilehdl);
	close($tmpoutfilehdl);
}
#
# This procedure will validates all the parameter values given in partition_utils.values
#
sub validate_partition_utils_values {
	if ($MAX_ADD_REAL{'start_date'} < 2 or $MAX_ADD_REAL{'start_date'} > 180 ) {
		return $ERR_LIMIT_REAL_START_DATE;   
	}
	if ($MAX_ADD_DELAYED{'start_date'}  < 2 or $MAX_ADD_DELAYED{'start_date'} > 180 ) {
		return $ERR_LIMIT_DELAYED_START_DATE;   
	}
	elsif ($MAX_ADD_REAL{'daily_quantity'} < 1 or $MAX_ADD_REAL{'daily_quantity'} > 150 ) {
		return $ERR_LIMIT_REAL_DAILY_QUANTITY;   
	}  
	elsif ($MAX_ADD_REAL{'weekly_quantity'} < 1 or $MAX_ADD_REAL{'weekly_quantity'} > 80 ) {
		return $ERR_LIMIT_REAL_WEEKLY_QUANTITY;   
	}
	elsif ($MAX_ADD_REAL{'monthly_quantity'} < 1 or $MAX_ADD_REAL{'monthly_quantity'} >24 ) {
		return $ERR_LIMIT_REAL_MONTHLY_QUANTITY;   
	}
	elsif ($MAX_ADD_DELAYED{'daily_quantity'} < 1 or $MAX_ADD_DELAYED{'daily_quantity'} > 150 ) {
		return $ERR_LIMIT_DELAYED_DAILY_QUANTITY;   
	}
	elsif ($MAX_ADD_DELAYED{'weekly_quantity'} < 1 or $MAX_ADD_DELAYED{'weekly_quantity'} > 80 ) {
		return $ERR_LIMIT_DELAYED_WEEKLY_QUANTITY;   
	}
	elsif ($MAX_ADD_DELAYED{'monthly_quantity'}  < 1 or $MAX_ADD_DELAYED{'monthly_quantity'} > 24 ) {
		return $ERR_LIMIT_DELAYED_MONTHLY_QUANTITY;   
	}
	elsif ( $MAX_ADD_REAL{'daily_width'} < 1 or  $MAX_ADD_REAL{'daily_width'} > 30 ) {
		return $ERR_LIMIT_REAL_DAILY_WIDTH;   
	}
	elsif ($MAX_ADD_REAL{'weekly_width'} < 1 or $MAX_ADD_REAL{'weekly_width'} > 10 ) {
		return $ERR_LIMIT_REAL_WEEKLY_WIDTH;   
	}
	elsif ($MAX_ADD_REAL{'monthly_width'} < 1 or $MAX_ADD_REAL{'monthly_width'} > 6 ) {
		return $ERR_LIMIT_REAL_MONTHLY_WIDTH;   
	}
	elsif ($MAX_ADD_DELAYED{'daily_width'} < 1 or $MAX_ADD_DELAYED{'daily_width'} > 30 ) {
		return $ERR_LIMIT_DELAYED_DAILY_WIDTH;   
	}
	elsif ($MAX_ADD_DELAYED{'weekly_width'} < 1 or $MAX_ADD_DELAYED{'weekly_width'} > 10 ) {
		return $ERR_LIMIT_DELAYED_WEEKLY_WIDTH;   
	}
	elsif ($MAX_ADD_DELAYED{'monthly_width'} < 1 or $MAX_ADD_DELAYED{'monthly_width'} > 6 ) {
		return $ERR_LIMIT_DELAYED_MONTHLY_WIDTH;   
	}
	elsif ($MAX_REMOVE_REAL{'older_than'} < 1 ) {
		return $ERR_LIMIT_REAL_OLDER_THAN;   
	}
	elsif ($MAX_REMOVE_DELAYED{'older_than'} < 1) {
		return $ERR_LIMIT_DELAYED_OLDER_THAN;   
	}
	elsif ($PURGE_THRESHOLD < 60 or $PURGE_THRESHOLD > 100 ) {
		return $ERR_LIMIT_PURGE_THRESHOLD;
	}
	elsif ($NUM_OF_PROCESSES < 1 or $NUM_OF_PROCESSES > 10 ) {
		return $ERR_LIMIT_NUM_OF_PROCESSES;
	}
	elsif ($MAX_DEL_REC < 1000 or $MAX_DEL_REC > 20000) {
		return $ERR_LIMIT_MAX_DEL_REC;
	}
	elsif ($MAX_DEL_REC_CHUNK < 500 or $MAX_DEL_REC_CHUNK > 5000) {
		return $ERR_LIMIT_MAX_DEL_REC_CHUNK;
	}
	else {
		return 0;
	}
}
#
# This procedure will search for any errors return from oracle
#
sub handle_errors {
	my $pin_partition_error	= 0;
	my $errcode		= $_[0];
	my $sess_no		= $_[1];
	my $proposed_date	= 0;
	if ($errcode == 0) {
		$pin_partition_error = 1;
		my @err_info = get_pin_partition_error_info($sess_no);
		$errcode  = $err_info[0];
		$proposed_date = $err_info[1];
	}
	if ($errcode == 0) {
		return 0;
	} elsif ($errcode == $ERR_NO_PURGE_EVENT or $errcode == $ERR_PURGE_ELIGIBILITY) {
		#
		# If partition has no purgable events or purgable poids < PURGE_THRESHOLD percent
		# Then it prints the messable about non eligibility for purging and selects next partition
		#
		print_error_message($ERR_NO_PURGE_EVENT);
		return $ERR_NO_PURGE_EVENT;
	} elsif ($errcode == $ERR_REAL_START_DATE_ACTIVE) {
		print "Proposed Start Date : $proposed_date or Later\n";
		print_error_message($ERR_REAL_START_DATE_ACTIVE);
	} elsif ($errcode == $ERR_DELAYED_START_DATE_ACTIVE) {
		print "Proposed Start Date : $proposed_date or Later\n";
		print_error_message($ERR_DELAYED_START_DATE_ACTIVE);
	} elsif ($errcode == $ERR_ONE_INSTANCE_ALLOWED) {
		print "Another Instance is in execution or the last operation was done".
			" unsuccessfully\n or it was stopped abnormally\n";
		print "If you are sure that there is no other instance running then\n\n".
			"Use --restart-- option to complete the last command\n";
		# exit without clean_up
		exit($errcode + 20000);
	} else {
		print_error_message($errcode);
	}		
	#
	# If any partition error raised in any of the parallel sql sessions,
	# then print the summary report of purge and exit without continuing for the next partition
	# 
	if ($pin_partition_error) {
		print $look_into_log_msg;
		if (lc($opt_o) eq "purge" and $sess_no != 0){
			&exe_sql("EXEC PIN_PARTITION.purge_report", 0);
		}
		clean_up(1);
		exit($errcode + 20000);		
	} else {
		#
		# If any oracle error raised in any of the parallel sql sessions,
		# then print the summary report of purge and exit without continuing for the next partition
		# 
		if (lc($opt_o) eq "purge" and $sess_no != 0){
			&exe_sql("EXEC PIN_PARTITION.purge_report", 0);
		}
		clean_up(1);
		exit($errcode - 10000);		
	}
}
#
# This procedure will search for any errors return from oracle 
#
sub print_error_message {  
	my $errcode = "$_[0]";
	%errormsgs = ();
	open(ERRORMSGFILE, "$ENV{PIN_HOME}/apps/partition_utils/partition_utils.resources") || 
			die "Could not open partition_utils.resources \n";
	while(<ERRORMSGFILE>) {
		chomp;  
		# Ignore comments and blank lines
		if (($_ eq " ") || ($_ =~ m/^#/)){	           
		}
		else {
			($key, $value) = split(/ /, $_,2);	
			$errormsgs{$key} = $value;		
		}
	}
	close(ERRORMSGFILE);
	$tempmsgs = $errormsgs{$errcode};
	#
	# If oracle returns ERR_NO_PURGE_EVENT its just a warning
	# So "ERROR" string should be avoided here
	#
	if ($errcode eq $ERR_NO_PURGE_EVENT) { 
		print "$tempmsgs\n"
	}
	else {
		print "ERROR($errcode) $tempmsgs\n"
	}
}
sub get_pin_partition_error_info {    	
	my $session_num		= $_[0];
	my $mycount		= 0;
	my $errcode		= 0;
	my $prop_date		= 0; 
	my $ctr			= 0;
	local ($tmpfile)	= "session.log";
	if ( $session_num != 0 ) {
		$tmpfile = "session".$session_num.".log";
	}
	open(TMPFILE, "$tmpfile") ||
			die "$me: cannot open $tmpfile\n";
	@logData = <TMPFILE>;
	foreach $line (@logData) {
		if ($line =~ /Information:/) {	
			print substr($line,index($line, "Infor")+13);
		} elsif ( $line =~ /POID/ or $ctr >= 1) {
			if ($ctr == 2) {
				$line =~ s/^\s+|\s+|\s+$//g;
				print $line,"\n";
			}
			$ctr++;
		}
	}
	foreach $line (@logData) {
		if ($line =~ /PINPARTITION_ERROR_NO/) {		
			if (index($line, $timeinsec) == -1) {
				$line=~m/(\d+)/g;			 
				$errcode = (-1)*($1);
				if (($errcode == $ERR_REAL_START_DATE_ACTIVE) 
					or ($errcode == $ERR_DELAYED_START_DATE_ACTIVE)) {	
				} else {				
					close(TMPFILE);
					return ($errcode, $prop_date);
				}
			}
		}
		if ($line =~ /PINPARTITION_PROPOSED_DATE/) {		
			$line=~m/(\d+)/g;
			$prop_date = $1;
			close(TMPFILE);
			return ($errcode, $prop_date);
		}
		if ($line =~/ORA-/) {
			$mycount = $mycount +1;
			print $line;
		}
	}
	if ($mycount == 0 ) {
		close(TMPFILE);
		return (0, 0);
	} 
	else {		
		close(TMPFILE);
		return ($ERR_UNKNOWN_PIN_PARTITION_CODE, 0);
	}
}
#
# This procedure will search for any errors return from oracle 
#
sub read_partition_names {
	local ($tmpfile)	= "session.log";
	my $found		= 0;
	my @par_list;
	open(TMPFILE, "$tmpfile") ||
			die "$me: cannot open $tmpfile\n";
	@logData = <TMPFILE>;
	#
	# reads partition names from session.log in between PARTITIONBEGIN and PARTITIONEND
	# number of processes will be read in case of the incompletion of previous purge command
	#
	foreach $line (@logData) {
		if( $found == 0)
		{
			if( $line =~ /PARTITIONBEGIN/ )
			{
				$found = 1;
			}
		} elsif ( $found == 1) {
			if( $line =~ /PARTITIONEND/)
			{
				$found = 2;
			}
			else {
				chomp($line);
				push(@par_list, $line);
			}
		} else {
			chomp($line);
			if( $line =~ /NUMBER_OF_PROCESSES/) {
				$nop = substr($line,20);
			}
			close(TMPFILE);
			return @par_list;
		}
	}
}

#
# reads the index type for the given class
#
sub read_index_type {
	local ($tmpfile)	= "session.log";
	open(TMPFILE, "$tmpfile") ||
			die "$me: cannot open $tmpfile\n";
	@logData = <TMPFILE>;
	foreach $line (@logData) {
		if( $line =~ /INDEX/ )
		{
			chomp($line);
			$index_type = substr($line, index($line, "INDEX") + 8);
			print "Index type = $index_type\n";
			last;
		}
	}
	close(TMPFILE);
}

#
# Check weather the given date is valid
# returns 1 for failure 0 to success
#
sub is_date_valid {
	my $input	= shift;
	my $month	= substr($input, 0, 2);
	my $day		= substr($input,2 ,2);  
	my $year	= substr($input, 4);      
	my $temp_date	= $year."/".$month."/".$day;

	if ($temp_date =~ m!^((?:19|20)\d\d)[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$!) {

		# At this point, $1 holds the year, $2 the month and $3 the day of the date entered

		if ($3 == 31 and ($2 == 4 or $2 == 6 or $2 == 9 or $2 == 11)) {

			return 1; # 31st of a month with 30 days

		} elsif ($3 >= 30 and $2 == 2) {

			return 1; # February 30th or 31st

		} elsif ($2 == 2 and $3 == 29 and not ($1 % 4 == 0 and ($1 % 100 != 0 or $1 % 400 == 0))) {

			return 1; # February 29th outside a leap year
		} else {
			return 0; # Valid date
		}
	} else {
		return 1; # Not a date
	}
}
#######################FUNCTION is_date_in_range#######################
sub is_date_in_range {
	my $start_date		= $_[0];
	my $days_past		= $_[1];
	my $days_future		= $_[2];	

	$tm = localtime;
	($day, $month, $year) = ($tm->mday, $tm->mon, $tm->year);
	$local_time = timelocal(0,0, 0,$day,$month,$year);
	$month  =substr($start_date, 0, 2);
	$day = substr($start_date,2 ,2);  
	$year = substr($start_date, 4);       
	$start_time = timelocal(0,0, 0,$day,($month -1),($year -1900));
	$time_past = $local_time - $days_past * 24*60*60;
	$time_future = $local_time+ $days_future * 24*60*60;
	if ($days_past != 0) {
		if(($start_time > $time_past) && ( $start_time < $time_future)) {
			return 0; #  Valid range
		}
		else { 
			return 1;
		}
	} else {
		if ($start_time < $time_future) {
			return 0; #  Valid range
		}
		else { 
			return 1;
		}
	}
}
#######################end_more_than_start#######################
sub end_more_than_start {
	my $start_date	= $_[0];
	my $end_date	= $_[1];

	$month = substr($start_date, 0, 2);
	$day = substr($start_date,2 ,2);  
	$year = substr($start_date, 4);       
	$start_time = timelocal(0,0, 0,$day,($month -1),($year -1900));

	$month = substr($end_date, 0, 2);
	$day = substr($end_date,2 ,2);  
	$year = substr($end_date, 4);       
	$end_time = timelocal(0,0, 0,$day,($month -1),($year -1900));

	if($end_time >= $start_time ) {
		return 0; #  Valid range
	}
	return 1; # Not Valid range
}

#
# This function counts the total number of arguments supplied.
#
sub get_no_of_arguments  {
	my $arg_count = 0;
	my $operation = shift;

	if (lc($operation) eq "add") {
		#
		# Type of partition
		#
		if (defined $opt_t) {
			++$arg_count;
		}
		#
		# startdate
		#
		if (defined $opt_s) {
			++$arg_count;
		}
		#
		#quantity
		#
		if (defined $opt_q) {
			++$arg_count;
		}
		#
		# unit
		#
		if (defined $opt_u) {
			++$arg_count;
		}
	}elsif ( lc($operation) eq "remove" ) {
		#
		# startdate
		#
		if (defined $opt_s) {
			++$arg_count;
		}
		#
		# enddate
		#
		if (defined $opt_e) {
			++$arg_count;
		}
	}elsif (lc($operation) eq "enable" ) {
		#
		# storable class
		#
		if (defined $opt_c) {
			++$arg_count;
		}
		if (defined $opt_t) {
			++$arg_count;
		}
	}elsif (lc($operation) eq "update" ) {
		#
		# No argument for update
		#		
		$arg_count =0;
	}elsif ( lc($operation) eq "purge" ) {
		#
		# enddate
		#
		if (defined $opt_e) {
			++$arg_count;
		}
	}elsif ( lc($operation) eq "maxpoid" ) {
		#
		# Type of partition
		#
		if (defined $opt_t) {
			++$arg_count;
		}
		#
		# date
		#
		if (defined $opt_s) {
			++$arg_count;
		}
	}else {
		die "Invalid option";
	}
	return $arg_count;
}
sub handle_invalid_syntax {
	print "$usage_all\n";
	handle_errors($ERR_INVALID_SYNTAX, 0);
}
sub string_exists {
	local($filename, $search_string) = @_;
	my $found = 0;
	open(TMPFILE, "$filename") ||
			die "$me: cannot open $tmpfile\n";
	@logData = <TMPFILE>;
	#
	# search for string
	#
	foreach $line (@logData) {
		if( $line =~ /$search_string/) {
			$found = 1;
			last;
		}
	}
	close(TMPFILE);
	return $found;
}
#
# This procedure will open multiple sql sessions based on NUMBER_OF_PROCESSES value
# and execute the given command in those sessions.
#
sub exec_in_parallel {
	local ($cmd, $process_flag) = @_;
	local $i = 1;
	local $temp = $cmd;
	for(; $i<=$nop; $i++) {
		sleep(2);
		if(fork() == 0) {
			if ($process_flag == 1) {
				$temp = $cmd."$i)";
			}
			&exe_sql($temp, $i);
			exit(0);
		}
	}
	#
	# This will wait till all the child processes gets complete
	#
	while(wait != -1) {
	}
	# Handle errors
	for($i = 1; $i <= $nop; $i++) {
		handle_errors(0, $i);
	}
}
#
# This procedure will perform the update operation
#
sub update_process {
	local ($delayed_flag, $force_flag) = @_;
	my $found = 0;
	my $cmd;
	print "Executing update_partitions_init procedure............\n";
	&exe_sql("EXEC PIN_PARTITION.update_partitions_init('$system','$osuser', '$dbuser',".
	"'$base_class', $delayed_flag, $nop, $exec_flag, $force_flag, $timeinsec)", 0);
	handle_errors(0, 0);
	read_index_type();
	$found = string_exists("session.log", "ALREADY_IN_SYNC");	
	if ($found == 0) {
		print "Executing update_partitions_exec procedure............\n";
		$cmd = "EXEC PIN_PARTITION.update_partitions_exec($delayed_flag, $exec_flag, $force_flag)";
		exec_in_parallel($cmd, 0);
	}
}
#
# This procedure will evaluates the given partition type.
#
sub evaluate_partition_type {
	if (defined $opt_t) {        	   	
		if (lc($opt_t) eq "realtime") {
			$partition_type_flag = 2;
		} elsif (lc($opt_t) eq "delayed") {
			if( $base_class ne "/event" ) {
				handle_errors($ERR_DELAYED_NOT_SUPPORTED, 0);
			}
			$partition_type_flag = 3;
		} else {
			handle_errors($ERR_INVALID_PARTITION_TYPE, 0);
		}
	}
}
#
# This procedure will check whether the given class is base class or not
#
sub validate_base_class {
	if(defined $opt_c) {
		if(rindex($opt_c,"/") == 0) {
			$base_class = lc($opt_c);
		}
		else {
			handle_errors($ERR_INVALID_BASE_CLASS_NAME, 0);
		}
	}
}
#
# This procedure will perform the drop operation
#
sub drop_partition_process {
	local ($delayed_flag, $GuardFlag) = @_;
	$tm = localtime;
	print "Begin Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",
				$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
	print "Executing drop_partitions_init............\n";
	&exe_sql("EXEC PIN_PARTITION.drop_partitions_init('$system','$osuser', '$dbuser',".
	"'$base_class','$opt_s','$opt_e',$GuardFlag,$delayed_flag, $nop, $exec_flag, $timeinsec)", 0);
	handle_errors(0, 0);		
	read_index_type();
	if (string_exists("session.log", "NOTHING_TO_DROP") == 0) {
		$cmd = "EXEC PIN_PARTITION.drop_partitions_exec($exec_flag)";
		print "Executing drop_partitions_exec procedure............\n";
		exec_in_parallel($cmd, 0);
	}	
	$tm = localtime;
	print "Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
}
#
# This procedure will perform the purge operation
#
sub purge_partition_process {
	local ($delayed_flag) = @_;
	$tm = localtime;
	print "Begin Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",
				$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
	print "Executing purge_partitions_init............\n";
	&exe_sql("EXEC PIN_PARTITION.purge_partitions_init('$system','$osuser', '$dbuser',".
	"'$base_class', '$opt_e', $delayed_flag, $nop, $exec_flag, 0, $timeinsec)", 0);
	read_index_type();
	handle_errors(0, 0);
	my (@par_array) = read_partition_names();
	do_purge(@par_array);
	$tm = localtime;
	print "Time is : ", $tm->year + 1900, "/",$tm->mon + 1,"/", $tm->mday," ",$tm->hour,":",$tm->min,":", $tm->sec, "\n" ; 
}
#
# This procedure will execute rebuild_indexes database procedure
#
sub rebuild_indexes{
	local ($cln_up) = @_;
	if ($index_type eq "GLOBAL") {
		print "Rebuilding indexes... \n";
		#
		# rebuild_indexes internally calls clean_up
		#
		&exe_sql("EXEC PIN_PARTITION.rebuild_indexes($cln_up)", 0);
		handle_errors(0, 0);		
	}
	else {
		clean_up(0);
	}
}
#
# This execute clean_up database procedure
#
sub clean_up{
	local ($cleanmode) = @_;
	&exe_sql("EXEC PIN_PARTITION.clean_up($cleanmode)", 0);
}

sub validate_class_name
{
	my $found = 0;
	my $cnt = 0;
	foreach $arg (@ARGV) {
		if ($found) {
			if ($arg !~ /^-/) {
				$cnt++;
			} else {
				last;
			}
		}
		if ($arg eq '-c') {
			$found = 1;
		}
	}
	if ($cnt > 1) {
		handle_errors($ERR_SINGLE_CLASS_NAME);
	}
}

